{"payload":{"meta":{"Graph":{"@Type":"81297157","@Value":{"Guid":"(Guid)4d1d6379-b2d5-4bdb-8637-f2bc37e5e789","ParentGuid":"(Guid)84c344e9-8333-4d2c-ad03-450a61369a8c","Name":"(string)SegmentedAndBlockReadExample","Properties":{"@Type":"2c41fa04:IDictionary","@Value":[{"@Key":"(Guid)829a18f2-c514-4f6e-9634-1df173429203","@Value":{"@Type":"829a18f2","@Value":{"ParentObjects":{"@Type":"fa2ee218:IDictionary","@Value":[{"@Key":"(Guid)d9b2b2cc-ea99-4c3b-aa42-1e5c49e65b84","@Value":"(Guid)04baf5d8-f9d1-4f2e-bcdb-ce9ddc288c94"}]}}}}]},"TypeGuid":"(Guid)6f9dac99-8de1-4efc-8465-68ac443b7d08","EmbeddedTypeGuids":{"@Type":"[Guid]","@Value":["(Guid)a9ed5b7e-75c5-4651-af16-d2c27e98cb94","(Guid)3b83b776-fb25-43b8-99f2-3c507c9143fc"]}}},"TypeInfos":{"2c41fa04":"{2c41fa04-1834-41c1-816e-303c7aa2c05b}","81297157":"{81297157-7ec9-45ce-845e-84cab2b88ade}","829a18f2":"{829a18f2-c514-4f6e-9634-1df173429203}","fa2ee218":"{fa2ee218-a39b-4b6d-b249-49dbddbd168a}","Guid":"System.Guid","string":"System.String"}},"object":{"Graph":{"@Type":"6f9dac99","@Value":{"SpecialFunc":{"@Type":"0db3d7bb:Enum","@Value":"None"},"Implementation":{"@Type":"3b83b776","@Value":{"TextDocument":{"@Type":"f3878285","@Value":{"TextBlobForSerialisation":"(string)RTrig(CLK := xEnable);\n\nIF RTrig.Q THEN\n\t// Rising edge for xEnable detected ==> Prepare SDO write function block\n\t\n\t// ==> Initialize read buffer with 0 (clear old read results)\n\tMEMUtils.MemSet(pbyBuffer := ADR(aData[0]), byValue := 0, dwSize := SIZEOF(aData));\n\t\n\t// ==> Set udiDataLength to read buffer length.\n\t// Note: Do not forget setting udiDataLength each time when you start a new SDO read operation. \n\t// This is necessary because udiDataLength is a VAR_IN_OUT variable and will be modified by SDORead function block!\n\t// It contains the number of valid bytes read by the function block.\n\tudiDataLength := SIZEOF(aData) - 1; //-1 only needed because CANopen strings are not null terminated! So we need one additional byte for the null termination. ==> Not needed for other datatypes!\nEND_IF\n\nIF SDORead.CONFIRM THEN\n\t// SDO Read successful. aData contains data (= Device Name); udiDataLength contains number of bytes read (string length without null termination).\n\txEnable := FALSE;\nELSIF SDORead.ERROR <> CiA405.CANOPEN_KERNEL_ERROR.CANOPEN_KERNEL_NO_ERROR THEN\n\t// Error occured\n\tIF SDORead.ERROR = CIA405.CANOPEN_KERNEL_ERROR.CANOPEN_KERNEL_OTHER_ERROR THEN\n\t\t//output error info contains abort code in little endian format\n\t\tMEMUtils.MemCpy(pbyDest := ADR(dwAbortCode), pbySrc := ADR(SDORead.ERRORINFO), dwSize := SIZEOF(dwAbortCode));\n\t\tMEMUtils.SwapLocalToIntel(pAddress := ADR(dwAbortCode), iSize := TO_INT(SIZEOF(dwAbortCode))); //function only swaps on big endian systems\t\n\tEND_IF\n\txEnable := FALSE;\nEND_IF\n\nSDORead(   Enable     := xEnable,\n\t\t   Network    := CANbus.NetId + 1, //CODESYS NetId starts by 0 (the number entered into the CANbus configurator); CiA405 NETWORK by 1; That is the reason why we have to increment it here.\n           Timeout    := 0, //Timeout for SDO read in ms. Here: 0 ==> no timeout\n           Device     := XN_312_GW_CAN.NodeID, // NodeID of destination device\n           Channel    := 0, //SDO channel which should be used. 0 means auto channeling ==> the next free channel will be used. It depends on the slave which settings are working here but 0 and channel 1 is always working. \n           Index      := 16#1008, //object index which should be read ==> 16#1008sub0 = Device Name\n           SubIndex   := 0, //object sub index which should be read ==> 16#1008sub0 = Device Name\n\t\t   MODE\t\t  := CIA405.SDO_MODE.AUTO, //Use SDO mode AUTO ==> Mode will be selected automatically. Use SDO_MODE.BLOCK for forcing Block Transfer.\n           Data       := ADR(aData), // Pointer to data buffer where result should be written to.\n           DataLength := udiDataLength //VAR_IN: Length of data buffer; VAR_OUT: Length of data written to data buffer.\n);","LineInfoPersistence":"(string)4d1d6379-b2d5-4bdb-8637-f2bc37e5e789_Impl_LineIds"}}}},"Interface":{"@Type":"a9ed5b7e","@Value":{"TextDocument":{"@Type":"f3878285","@Value":{"TextBlobForSerialisation":"(string)// This program uses CiA405.SDO_READ_DATA for reading more than 4 byte from a slave using segmented or block transfer.\n//\n// This example code reads object 16#1008sub0 which is the device name.\n// CiA405.SDO_READ_DATA is a universal function block which can be also used for expedited transfer (<= 4byte).\n// If you never want to read more than 4 byte use the CIA405.SDO_READ4 functionblock instead.\n// Set xEnable to TRUE in online mode to get the program working.\nPROGRAM SegmentedAndBlockReadExample\nVAR\n\txEnable       : BOOL; // Set this variable to true to start the example code.\n\tpsData        : POINTER TO STRING(MAX_CHAR - 1) := ADR(aData); // Result: Device Name\n\tdwAbortCode\t  : DWORD; //contains abort code in case of error\n\n\tSDORead    \t  : CIA405.SDO_READ_DATA;\n\tRTrig \t\t  : Standard.R_TRIG;\t\t\t\t\t\t\t\t\t\t  \n\taData\t      : ARRAY[0..MAX_CHAR] OF BYTE;\n\tudiDataLength : UDINT;\nEND_VAR\nVAR CONSTANT\n\tMAX_CHAR : INT := 256;\nEND_VAR","LineInfoPersistence":"(string)4d1d6379-b2d5-4bdb-8637-f2bc37e5e789_Decl_LineIds"}}}},"UniqueIdGenerator":"(string)201","POULevel":{"@Type":"8e575c5b:Enum","@Value":"Standard"},"ChildObjectGuids":{"@Type":"ArrayList:IList","@Value":[]},"AddAttributeSubsequent":"(bool)False"}},"TypeInfos":{"0db3d7bb":"{0db3d7bb-cde0-4416-9a7b-ce49a0124323}","3b83b776":"{3b83b776-fb25-43b8-99f2-3c507c9143fc}","6f9dac99":"{6f9dac99-8de1-4efc-8465-68ac443b7d08}","8e575c5b":"{8e575c5b-1d37-49c6-941b-5c0ec7874787}","a9ed5b7e":"{a9ed5b7e-75c5-4651-af16-d2c27e98cb94}","ArrayList":"System.Collections.ArrayList","bool":"System.Boolean","f3878285":"{f3878285-8e4f-490b-bb1b-9acbb7eb04db}","string":"System.String"}}},"FormatVersion":"1.0"}